// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: query.sql

package sqlc

import (
	"context"
	"database/sql"
	"strings"
)

const deleteVar = `-- name: DeleteVar :exec
DELETE FROM var WHERE id = ?
`

func (q *Queries) DeleteVar(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteVar, id)
	return err
}

const listFilteredLinks = `-- name: ListFilteredLinks :many
SELECT
   l.id,
   l.original_url,
   l.created_time,
   l.visited_time,
   c.id AS content_id,
   c.title,
   c.body
FROM
   link l
    LEFT JOIN content c ON c.link_id=l.id
WHERE true
   AND l.id IN (/*SLICE:ids*/?)
   AND archived IN (/*SLICE:link_archived*/?)
GROUP BY
   l.id,
   l.original_url,
   l.created_time,
   l.visited_time,
   c.id,
   c.title,
   c.body
HAVING 1=0
   OR c.created=max(c.created)
   OR count(c.id)=0
ORDER BY
   l.original_url
`

type ListFilteredLinksParams struct {
	Ids          []int64 `json:"ids"`
	LinkArchived []int64 `json:"link_archived"`
}

type ListFilteredLinksRow struct {
	ID          int64          `json:"id"`
	OriginalUrl string         `json:"original_url"`
	CreatedTime sql.NullString `json:"created_time"`
	VisitedTime sql.NullString `json:"visited_time"`
	ContentID   sql.NullInt64  `json:"content_id"`
	Title       sql.NullString `json:"title"`
	Body        sql.NullString `json:"body"`
}

func (q *Queries) ListFilteredLinks(ctx context.Context, arg ListFilteredLinksParams) ([]ListFilteredLinksRow, error) {
	query := listFilteredLinks
	var queryParams []interface{}
	if len(arg.Ids) > 0 {
		for _, v := range arg.Ids {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:ids*/?", strings.Repeat(",?", len(arg.Ids))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:ids*/?", "NULL", 1)
	}
	if len(arg.LinkArchived) > 0 {
		for _, v := range arg.LinkArchived {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:link_archived*/?", strings.Repeat(",?", len(arg.LinkArchived))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:link_archived*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListFilteredLinksRow
	for rows.Next() {
		var i ListFilteredLinksRow
		if err := rows.Scan(
			&i.ID,
			&i.OriginalUrl,
			&i.CreatedTime,
			&i.VisitedTime,
			&i.ContentID,
			&i.Title,
			&i.Body,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listGroupsByType = `-- name: ListGroupsByType :many
SELECT id, name, type, slug, created_time, latest_time, created, latest, archived
FROM ` + "`" + `group` + "`" + `
WHERE true
   AND type = ?
   AND archived IN (/*SLICE:group_archived*/?)
ORDER BY name
`

type ListGroupsByTypeParams struct {
	Type          string  `json:"type"`
	GroupArchived []int64 `json:"group_archived"`
}

func (q *Queries) ListGroupsByType(ctx context.Context, arg ListGroupsByTypeParams) ([]Group, error) {
	query := listGroupsByType
	var queryParams []interface{}
	queryParams = append(queryParams, arg.Type)
	if len(arg.GroupArchived) > 0 {
		for _, v := range arg.GroupArchived {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:group_archived*/?", strings.Repeat(",?", len(arg.GroupArchived))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:group_archived*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Group
	for rows.Next() {
		var i Group
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Type,
			&i.Slug,
			&i.CreatedTime,
			&i.LatestTime,
			&i.Created,
			&i.Latest,
			&i.Archived,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listGroupsType = `-- name: ListGroupsType :many
SELECT DISTINCT
   gt.type,
   gt.name,
   gt.plural,
   COUNT(DISTINCT g.id) AS group_count,
   COUNT(DISTINCT g.archived=1) AS group_archived,
   CAST(CASE WHEN g.ID IS NULL THEN 0
      ELSE COUNT(DISTINCT rg.link_id) END AS INTEGER) AS link_count,
   COUNT(DISTINCT l.archived=1) AS link_archived,
   gt.sort
FROM group_type gt
   LEFT JOIN ` + "`" + `group` + "`" + ` g ON gt.type=g.type
   LEFT JOIN link_group rg ON g.id=rg.group_id
   LEFT JOIN link l ON l.id=rg.link_id
GROUP BY
   gt.sort,
   gt.type,
   gt.name
ORDER BY
   gt.sort
`

type ListGroupsTypeRow struct {
	Type          string         `json:"type"`
	Name          sql.NullString `json:"name"`
	Plural        sql.NullString `json:"plural"`
	GroupCount    int64          `json:"group_count"`
	GroupArchived int64          `json:"group_archived"`
	LinkCount     int64          `json:"link_count"`
	LinkArchived  int64          `json:"link_archived"`
	Sort          sql.NullInt64  `json:"sort"`
}

func (q *Queries) ListGroupsType(ctx context.Context) ([]ListGroupsTypeRow, error) {
	rows, err := q.db.QueryContext(ctx, listGroupsType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListGroupsTypeRow
	for rows.Next() {
		var i ListGroupsTypeRow
		if err := rows.Scan(
			&i.Type,
			&i.Name,
			&i.Plural,
			&i.GroupCount,
			&i.GroupArchived,
			&i.LinkCount,
			&i.LinkArchived,
			&i.Sort,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLatestUnparsedLinkURLs = `-- name: ListLatestUnparsedLinkURLs :many
SELECT
   id,
   original_url
FROM link
WHERE true
   AND sld == ''
   AND archived IN (/*SLICE:link_archived*/?)
ORDER BY
   id DESC
LIMIT 8
`

type ListLatestUnparsedLinkURLsRow struct {
	ID          int64  `json:"id"`
	OriginalUrl string `json:"original_url"`
}

func (q *Queries) ListLatestUnparsedLinkURLs(ctx context.Context, linkArchived []int64) ([]ListLatestUnparsedLinkURLsRow, error) {
	query := listLatestUnparsedLinkURLs
	var queryParams []interface{}
	if len(linkArchived) > 0 {
		for _, v := range linkArchived {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:link_archived*/?", strings.Repeat(",?", len(linkArchived))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:link_archived*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListLatestUnparsedLinkURLsRow
	for rows.Next() {
		var i ListLatestUnparsedLinkURLsRow
		if err := rows.Scan(&i.ID, &i.OriginalUrl); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLinkIdsByGroupSlugs = `-- name: ListLinkIdsByGroupSlugs :many
SELECT CAST(l.id AS INTEGER) AS link_id
FROM
   link l
   JOIN link_group rg ON l.id=rg.link_id
   JOIN ` + "`" + `group` + "`" + ` g ON g.id=rg.group_id
WHERE true
   AND g.slug IN (/*SLICE:slugs*/?)
   AND l.archived IN (/*SLICE:link_archived*/?)
`

type ListLinkIdsByGroupSlugsParams struct {
	Slugs        []string `json:"slugs"`
	LinkArchived []int64  `json:"link_archived"`
}

func (q *Queries) ListLinkIdsByGroupSlugs(ctx context.Context, arg ListLinkIdsByGroupSlugsParams) ([]int64, error) {
	query := listLinkIdsByGroupSlugs
	var queryParams []interface{}
	if len(arg.Slugs) > 0 {
		for _, v := range arg.Slugs {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:slugs*/?", strings.Repeat(",?", len(arg.Slugs))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:slugs*/?", "NULL", 1)
	}
	if len(arg.LinkArchived) > 0 {
		for _, v := range arg.LinkArchived {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:link_archived*/?", strings.Repeat(",?", len(arg.LinkArchived))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:link_archived*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var link_id int64
		if err := rows.Scan(&link_id); err != nil {
			return nil, err
		}
		items = append(items, link_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLinkIdsByGroupType = `-- name: ListLinkIdsByGroupType :many
SELECT CAST(link_id AS INTEGER) AS link_id
FROM link_group lg
        JOIN ` + "`" + `group` + "`" + ` g ON lg.group_id = g.id
        JOIN link l ON l.id=lg.link_id
WHERE true
   AND g.type IN (/*SLICE:groupTypes*/?)
   AND l.archived IN (/*SLICE:link_archived*/?)
`

type ListLinkIdsByGroupTypeParams struct {
	GroupTypes   []string `json:"groupTypes"`
	LinkArchived []int64  `json:"link_archived"`
}

func (q *Queries) ListLinkIdsByGroupType(ctx context.Context, arg ListLinkIdsByGroupTypeParams) ([]int64, error) {
	query := listLinkIdsByGroupType
	var queryParams []interface{}
	if len(arg.GroupTypes) > 0 {
		for _, v := range arg.GroupTypes {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:groupTypes*/?", strings.Repeat(",?", len(arg.GroupTypes))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:groupTypes*/?", "NULL", 1)
	}
	if len(arg.LinkArchived) > 0 {
		for _, v := range arg.LinkArchived {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:link_archived*/?", strings.Repeat(",?", len(arg.LinkArchived))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:link_archived*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var link_id int64
		if err := rows.Scan(&link_id); err != nil {
			return nil, err
		}
		items = append(items, link_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLinkIdsByMetadata = `-- name: ListLinkIdsByMetadata :many
;

SELECT CAST(m.link_id AS INTEGER) AS link_id
FROM metadata m
   JOIN link l ON l.id=m.link_id
WHERE true
   AND m.kv_pair IN (/*SLICE:kv_pairs*/?)
   AND l.archived IN (/*SLICE:link_archived*/?)
`

type ListLinkIdsByMetadataParams struct {
	KvPairs      []string `json:"kv_pairs"`
	LinkArchived []int64  `json:"link_archived"`
}

func (q *Queries) ListLinkIdsByMetadata(ctx context.Context, arg ListLinkIdsByMetadataParams) ([]int64, error) {
	query := listLinkIdsByMetadata
	var queryParams []interface{}
	if len(arg.KvPairs) > 0 {
		for _, v := range arg.KvPairs {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:kv_pairs*/?", strings.Repeat(",?", len(arg.KvPairs))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:kv_pairs*/?", "NULL", 1)
	}
	if len(arg.LinkArchived) > 0 {
		for _, v := range arg.LinkArchived {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:link_archived*/?", strings.Repeat(",?", len(arg.LinkArchived))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:link_archived*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var link_id int64
		if err := rows.Scan(&link_id); err != nil {
			return nil, err
		}
		items = append(items, link_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLinkIdsNotInGroupType = `-- name: ListLinkIdsNotInGroupType :many
SELECT CAST(l.id AS INTEGER) AS link_id
FROM link l
WHERE TRUE
   AND l.archived IN (/*SLICE:link_archived*/?)
   AND l.id NOT IN (
      SELECT lg.link_id
      FROM link_group lg
        JOIN ` + "`" + `group` + "`" + ` g ON lg.group_id = g.id
      WHERE g.type IN (/*SLICE:groupTypes*/?)
   )
`

type ListLinkIdsNotInGroupTypeParams struct {
	LinkArchived []int64  `json:"link_archived"`
	GroupTypes   []string `json:"groupTypes"`
}

func (q *Queries) ListLinkIdsNotInGroupType(ctx context.Context, arg ListLinkIdsNotInGroupTypeParams) ([]int64, error) {
	query := listLinkIdsNotInGroupType
	var queryParams []interface{}
	if len(arg.LinkArchived) > 0 {
		for _, v := range arg.LinkArchived {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:link_archived*/?", strings.Repeat(",?", len(arg.LinkArchived))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:link_archived*/?", "NULL", 1)
	}
	if len(arg.GroupTypes) > 0 {
		for _, v := range arg.GroupTypes {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:groupTypes*/?", strings.Repeat(",?", len(arg.GroupTypes))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:groupTypes*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var link_id int64
		if err := rows.Scan(&link_id); err != nil {
			return nil, err
		}
		items = append(items, link_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLinks = `-- name: ListLinks :many
SELECT id, scheme, subdomain, sld, tld, port, path, "query", fragment, original_url, url, created_time, visited_time, created, visited, archived
FROM link
WHERE archived IN (/*SLICE:link_archived*/?)
ORDER BY original_url
LIMIT 100
`

func (q *Queries) ListLinks(ctx context.Context, linkArchived []int64) ([]Link, error) {
	query := listLinks
	var queryParams []interface{}
	if len(linkArchived) > 0 {
		for _, v := range linkArchived {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:link_archived*/?", strings.Repeat(",?", len(linkArchived))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:link_archived*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Link
	for rows.Next() {
		var i Link
		if err := rows.Scan(
			&i.ID,
			&i.Scheme,
			&i.Subdomain,
			&i.Sld,
			&i.Tld,
			&i.Port,
			&i.Path,
			&i.Query,
			&i.Fragment,
			&i.OriginalUrl,
			&i.Url,
			&i.CreatedTime,
			&i.VisitedTime,
			&i.Created,
			&i.Visited,
			&i.Archived,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMetadata = `-- name: ListMetadata :many
SELECT m.id, link_id, "key", value, kv_pair, m.created_time, modified_time, m.created, modified, l.id, scheme, subdomain, sld, tld, port, path, "query", fragment, original_url, url, l.created_time, visited_time, l.created, visited, archived
FROM metadata m
   JOIN link l ON m.link_id = l.id
WHERE l.archived IN (/*SLICE:link_archived*/?)
ORDER BY link_id,key DESC
`

type ListMetadataRow struct {
	ID            int64          `json:"id"`
	LinkID        int64          `json:"link_id"`
	Key           string         `json:"key"`
	Value         string         `json:"value"`
	KvPair        string         `json:"kv_pair"`
	CreatedTime   sql.NullString `json:"created_time"`
	ModifiedTime  sql.NullString `json:"modified_time"`
	Created       sql.NullInt64  `json:"created"`
	Modified      sql.NullInt64  `json:"modified"`
	ID_2          int64          `json:"id_2"`
	Scheme        string         `json:"scheme"`
	Subdomain     string         `json:"subdomain"`
	Sld           string         `json:"sld"`
	Tld           string         `json:"tld"`
	Port          string         `json:"port"`
	Path          string         `json:"path"`
	Query         string         `json:"query"`
	Fragment      string         `json:"fragment"`
	OriginalUrl   string         `json:"original_url"`
	Url           sql.NullString `json:"url"`
	CreatedTime_2 sql.NullString `json:"created_time_2"`
	VisitedTime   sql.NullString `json:"visited_time"`
	Created_2     sql.NullInt64  `json:"-"`
	Visited       sql.NullInt64  `json:"visited"`
	Archived      int64          `json:"archived"`
}

func (q *Queries) ListMetadata(ctx context.Context, linkArchived []int64) ([]ListMetadataRow, error) {
	query := listMetadata
	var queryParams []interface{}
	if len(linkArchived) > 0 {
		for _, v := range linkArchived {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:link_archived*/?", strings.Repeat(",?", len(linkArchived))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:link_archived*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListMetadataRow
	for rows.Next() {
		var i ListMetadataRow
		if err := rows.Scan(
			&i.ID,
			&i.LinkID,
			&i.Key,
			&i.Value,
			&i.KvPair,
			&i.CreatedTime,
			&i.ModifiedTime,
			&i.Created,
			&i.Modified,
			&i.ID_2,
			&i.Scheme,
			&i.Subdomain,
			&i.Sld,
			&i.Tld,
			&i.Port,
			&i.Path,
			&i.Query,
			&i.Fragment,
			&i.OriginalUrl,
			&i.Url,
			&i.CreatedTime_2,
			&i.VisitedTime,
			&i.Created_2,
			&i.Visited,
			&i.Archived,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const loadGroup = `-- name: LoadGroup :one

SELECT id, name, type, slug, created_time, latest_time, created, latest, archived FROM ` + "`" + `group` + "`" + `
WHERE true
   AND id = ?
   AND archived IN (/*SLICE:group_archived*/?)
LIMIT 1
`

type LoadGroupParams struct {
	ID            int64   `json:"id"`
	GroupArchived []int64 `json:"group_archived"`
}

// noinspection SqlResolveForFile @ any/"sqlc"
func (q *Queries) LoadGroup(ctx context.Context, arg LoadGroupParams) (Group, error) {
	query := loadGroup
	var queryParams []interface{}
	queryParams = append(queryParams, arg.ID)
	if len(arg.GroupArchived) > 0 {
		for _, v := range arg.GroupArchived {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:group_archived*/?", strings.Repeat(",?", len(arg.GroupArchived))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:group_archived*/?", "NULL", 1)
	}
	row := q.db.QueryRowContext(ctx, query, queryParams...)
	var i Group
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Type,
		&i.Slug,
		&i.CreatedTime,
		&i.LatestTime,
		&i.Created,
		&i.Latest,
		&i.Archived,
	)
	return i, err
}

const loadGroupType = `-- name: LoadGroupType :one
SELECT type, sort, name, plural, description FROM group_type WHERE type = ? LIMIT 1
`

func (q *Queries) LoadGroupType(ctx context.Context, type_ string) (GroupType, error) {
	row := q.db.QueryRowContext(ctx, loadGroupType, type_)
	var i GroupType
	err := row.Scan(
		&i.Type,
		&i.Sort,
		&i.Name,
		&i.Plural,
		&i.Description,
	)
	return i, err
}

const loadGroupsBySlug = `-- name: LoadGroupsBySlug :one
SELECT id, name, type, slug, created_time, latest_time, created, latest, archived FROM ` + "`" + `group` + "`" + `
WHERE true
   AND slug = ?
   AND archived IN (/*SLICE:group_archived*/?)
LIMIT 1
`

type LoadGroupsBySlugParams struct {
	Slug          string  `json:"slug"`
	GroupArchived []int64 `json:"group_archived"`
}

func (q *Queries) LoadGroupsBySlug(ctx context.Context, arg LoadGroupsBySlugParams) (Group, error) {
	query := loadGroupsBySlug
	var queryParams []interface{}
	queryParams = append(queryParams, arg.Slug)
	if len(arg.GroupArchived) > 0 {
		for _, v := range arg.GroupArchived {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:group_archived*/?", strings.Repeat(",?", len(arg.GroupArchived))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:group_archived*/?", "NULL", 1)
	}
	row := q.db.QueryRowContext(ctx, query, queryParams...)
	var i Group
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Type,
		&i.Slug,
		&i.CreatedTime,
		&i.LatestTime,
		&i.Created,
		&i.Latest,
		&i.Archived,
	)
	return i, err
}

const loadLink = `-- name: LoadLink :one
SELECT id, scheme, subdomain, sld, tld, port, path, "query", fragment, original_url, url, created_time, visited_time, created, visited, archived FROM link WHERE archived IN (/*SLICE:link_archived*/?) AND id = ? LIMIT 1
`

type LoadLinkParams struct {
	LinkArchived []int64 `json:"link_archived"`
	ID           int64   `json:"id"`
}

func (q *Queries) LoadLink(ctx context.Context, arg LoadLinkParams) (Link, error) {
	query := loadLink
	var queryParams []interface{}
	if len(arg.LinkArchived) > 0 {
		for _, v := range arg.LinkArchived {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:link_archived*/?", strings.Repeat(",?", len(arg.LinkArchived))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:link_archived*/?", "NULL", 1)
	}
	queryParams = append(queryParams, arg.ID)
	row := q.db.QueryRowContext(ctx, query, queryParams...)
	var i Link
	err := row.Scan(
		&i.ID,
		&i.Scheme,
		&i.Subdomain,
		&i.Sld,
		&i.Tld,
		&i.Port,
		&i.Path,
		&i.Query,
		&i.Fragment,
		&i.OriginalUrl,
		&i.Url,
		&i.CreatedTime,
		&i.VisitedTime,
		&i.Created,
		&i.Visited,
		&i.Archived,
	)
	return i, err
}

const updateLinkParts = `-- name: UpdateLinkParts :exec

UPDATE link
SET
   scheme = ?,
   subdomain = ?,
   sld = ?,
   tld = ?,
   port = ?,
   path = ?,
   query = ?,
   fragment = ?
WHERE
   original_url = ?
`

type UpdateLinkPartsParams struct {
	Scheme      string `json:"scheme"`
	Subdomain   string `json:"subdomain"`
	Sld         string `json:"sld"`
	Tld         string `json:"tld"`
	Port        string `json:"port"`
	Path        string `json:"path"`
	Query       string `json:"query"`
	Fragment    string `json:"fragment"`
	OriginalUrl string `json:"original_url"`
}

// LIMIT was chosen as slice len == slice cap for 8
func (q *Queries) UpdateLinkParts(ctx context.Context, arg UpdateLinkPartsParams) error {
	_, err := q.db.ExecContext(ctx, updateLinkParts,
		arg.Scheme,
		arg.Subdomain,
		arg.Sld,
		arg.Tld,
		arg.Port,
		arg.Path,
		arg.Query,
		arg.Fragment,
		arg.OriginalUrl,
	)
	return err
}

const upsertGroupsFromVarJSON = `-- name: UpsertGroupsFromVarJSON :exec
INSERT INTO ` + "`" + `group` + "`" + ` (name,type,slug)
SELECT
   json_extract(r.value,'$.name') AS name,
   json_extract(r.value,'$.type') AS type,
   json_extract(r.value,'$.slug') AS slug
FROM var
   JOIN json_each( var.value ) r ON var.key='json'
WHERE var.id = ?
ON CONFLICT (name,type)
   DO UPDATE
   SET latest = strftime('%s','now')
`

func (q *Queries) UpsertGroupsFromVarJSON(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, upsertGroupsFromVarJSON, id)
	return err
}

const upsertLinkGroupsFromVarJSON = `-- name: UpsertLinkGroupsFromVarJSON :exec
INSERT INTO link_group (group_id, link_id)
SELECT g.id, r.id
FROM var
   JOIN json_each( var.value ) j ON var.key='json'
   JOIN link r ON r.original_url=json_extract(j.value,'$.link_url')
   JOIN ` + "`" + `group` + "`" + ` g ON true
      AND g.name=json_extract(j.value,'$.group_name')
      AND g.type=json_extract(j.value,'$.group_type')
WHERE var.id = ?
ON CONFLICT (group_id, link_id)
   DO UPDATE
            SET latest = strftime('%s','now')
`

func (q *Queries) UpsertLinkGroupsFromVarJSON(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, upsertLinkGroupsFromVarJSON, id)
	return err
}

const upsertLinksFromVarJSON = `-- name: UpsertLinksFromVarJSON :exec
INSERT INTO link (original_url)
SELECT r.value AS url
FROM var
   JOIN json_each( var.value ) r ON var.key='json'
WHERE var.id = ?
ON CONFLICT (original_url)
   DO UPDATE
            SET visited = strftime('%s','now')
`

func (q *Queries) UpsertLinksFromVarJSON(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, upsertLinksFromVarJSON, id)
	return err
}

const upsertMetadataFromVarJSON = `-- name: UpsertMetadataFromVarJSON :exec
INSERT INTO metadata (link_id, key, value)
SELECT
   r.id,
   json_extract(kv.value,'$.key'),
   json_extract(kv.value,'$.value')
FROM var
   JOIN json_each( var.value ) kv ON var.key='json'
   JOIN link r ON r.original_url=json_extract(kv.value,'$.url')
WHERE var.id = ?
   ON CONFLICT (link_id,key)
   DO UPDATE
      SET value = excluded.value
`

func (q *Queries) UpsertMetadataFromVarJSON(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, upsertMetadataFromVarJSON, id)
	return err
}

const upsertVar = `-- name: UpsertVar :execlastid
INSERT INTO var (key,value) VALUES (?,?)
ON CONFLICT (key) DO UPDATE SET value = excluded.value
`

type UpsertVarParams struct {
	Key   string         `json:"key"`
	Value sql.NullString `json:"value"`
}

func (q *Queries) UpsertVar(ctx context.Context, arg UpsertVarParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, upsertVar, arg.Key, arg.Value)
	if err != nil {
		return 0, err
	}
	return result.LastInsertId()
}
